name: CI Pipeline
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # Job 1: Tests unitaires backend (FastAPI + Pytest)
  backend-tests:
    name: Backend Unit Tests
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: test_db
        # Healthcheck pour attendre que MySQL soit prêt
        options: >-
          --health-cmd "mysqladmin ping -h 127.0.0.1 -uroot -proot --silent"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'                         # Cache pip pour accélérer les installs:contentReference[oaicite:6]{index=6}
          cache-dependency-path: Server/requirements.txt
      - name: Install backend dependencies
        run: pip install -r Server/requirements.txt
      - name: Run backend tests (Pytest)
        # On reste à la racine du repo pour que 'Server/app/models/pipeline.pkl' soit trouvable
        env:
          # Exemple de variable de connexion DB si nécessaire (FastAPI Settings)
          DATABASE_URL: mysql+pymysql://root:root@127.0.0.1:3306/test_db
        run: pytest Server

  # Job 2: Test de chargement du modèle ML
  ml-model-test:
    name: ML Model Loading Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'
          cache-dependency-path: Server/requirements.txt
      - name: Install dependencies (ML)
        run: pip install -r Server/requirements.txt
      - name: Load model and test prediction
        run: |
          python - <<'PYCODE'
          import pickle, sys
          import numpy as np
          model_path = "Server/app/models/pipeline.pkl"
          try:
              with open(model_path, "rb") as f:
                  model = pickle.load(f)
          except Exception as e:
              print(f"❌ Unable to load model from {model_path}: {e}")
              sys.exit(1)
          try:
              # Tentative de prédiction sur un input minimal (exemple: vecteur de zéros)
              dummy_input = np.zeros((1, model.n_features_in_)) if hasattr(model, 'n_features_in_') else [[0]]
              result = model.predict(dummy_input)
              print("✅ Model loaded and predict() ran successfully. Output:", result)
          except Exception as e:
              print("❌ Model loaded, but prediction failed:", e)
              sys.exit(1)
          PYCODE

  # Job 3: Tests d’intégration frontend (React/Vite + Vitest)
  frontend-tests:
    name: Frontend Integration Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'                         # Cache npm (dépendances Node):contentReference[oaicite:7]{index=7}
          cache-dependency-path: Client/package-lock.json
      - name: Install frontend dependencies
        working-directory: Client
        run: npm ci
      - name: Run frontend tests (Vitest)
        working-directory: Client
        run: npm run test

  # Job 4: Analyse SonarQube (statique + Quality Gate)
  sonar-analysis:
    name: SonarQube Analysis
    runs-on: ubuntu-latest
    needs: [backend-tests, ml-model-test, frontend-tests]   # Exécuter Sonar une fois tous les tests passés
    steps:
      - name: Checkout code (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0                    # Nécessaire pour une analyse SonarQube complète:contentReference[oaicite:8]{index=8}
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      - name: SonarQube Quality Gate
        if: ${{ success() }}                # (Optionnel) Exécuter la vérification du Quality Gate si le scan a réussi
        uses: SonarSource/sonarqube-quality-gate-action@master
        with:
          pollingTimeoutSec: 300            # Temps max d’attente du Quality Gate (5 minutes):contentReference[oaicite:9]{index=9}
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

  # Job 5: Test d’accessibilité avec Pa11y
  accessibility-test:
    name: Accessibility Tests (Pa11y)
    runs-on: ubuntu-latest
    needs: [frontend-tests]                 # Lance l'accessibility test après les tests frontend
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: Client/package-lock.json
      - name: Install and build frontend
        working-directory: Client
        run: |
          npm ci
          npm run build
      - name: Run Pa11y accessibility scan
        working-directory: Client
        run: |
          # Installer wait-on et pa11y-ci si pas déjà présents
          npm install -g wait-on pa11y-ci
          # Lancer le serveur de prévisualisation en arrière-plan
          npm run preview & 
          # Attendre que le port 4173 (Vite preview) soit prêt
          npx wait-on http://localhost:4173 
          # Lancer l’analyse Pa11y sur la page d’accueil
          npx pa11y-ci http://localhost:4173 
          # Arrêter le serveur local une fois le scan terminé
          kill $(jobs -p) || true
